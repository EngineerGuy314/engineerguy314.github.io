<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Spot Search Dashboard - Traquito</title>


        <script src="/js/sorttable.js"></script>
<!-- https://github.com/apvarun/toastify-js/blob/master/README.md -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/toastify-js"></script>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/toastify-js/src/toastify.min.css">


<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-07H1M3KB40"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-07H1M3KB40');
</script>

        <script type='module'>
import * as autl from '/trackergui/js/AppUtl.js';
import { TabularData } from '/js/TabularData.js';
import * as utl from '/js/Utl.js';
import { SpotSearchCombined } from '/js/SpotSearch.js';
import { WSPREncoded } from '/js/WSPREncoded.js';



export class App
{
    constructor()
    {
        this.tdAttrSet = new Set();

        this.ss = new SpotSearchCombined();

        this.dt__data = new Map();

        this.domBand = document.getElementById("band");
        this.domChannel = document.getElementById("channel");
        this.domCallsign = document.getElementById("callsign");
        this.domLimit = document.getElementById("limit");
        this.domDtGte = document.getElementById("dtGte");
        this.domDtLte = document.getElementById("dtLte");
        this.domGo = document.getElementById("go");
        this.domQueryLinkRegular = document.getElementById("queryLinkRegular");
        this.domQueryLinkEncoded = document.getElementById("queryLinkEncoded");
        this.domStatus = document.getElementById("status");
        this.domTargetTableCombined = document.getElementById("targetTableCombined");
        this.domDownloadCombined = document.getElementById("downloadCombined");
        this.domCopyCombined = document.getElementById("copyCombined");

        this.domGo.onclick = e => {
            this.OnFormChange();
        };

        let FilenamePrefix = () => {
            return `${this.GetBand()}_${this.GetChannelPadded()}_${this.GetCallsign()}_${this.GetTimeStart()}_${this.GetTimeEndRaw()}`;
        };
        this.domDownloadCombined.onclick = e => {
            utl.DownloadCsv(
                utl.MakeFilename(`${FilenamePrefix()}_Combined.csv`),
                                 utl.TableToCsv(this.GetTargetTableCombined()));
        };
        this.domCopyCombined.onclick = e => {
            utl.CopyElementToClipboard("targetTableCombined");
            autl.ToastOk("Copied");
        };

        // define the list of iframes and map to what data to send them
        this.ifInfoList = [
            {
                id: "graphAltitude",
                fn: from => this.OnGraphAltitude(from),
            },
            {
                id: "graphSpeed",
                fn: from => this.OnGraphSpeed(from),
            },
            {
                id: "graphTemperature",
                fn: from => this.OnGraphTemperature(from),
            },
            {
                id: "graphVoltage",
                fn: from => this.OnGraphVoltage(from),
            },
        ];

        this.ifWin__cb = new Map();
        for (let ifInfo of this.ifInfoList)
        {
            let ifWin = document.getElementById(ifInfo.id).contentWindow;
            this.ifWin__cb.set(ifWin, ifInfo.fn);
        }

        window.addEventListener("message", e => {
            let from = e.source;

            if (this.ifWin__cb.has(from))
            {
                this.ifWin__cb.get(from)(from);
            }
        });

        this.OnPageLoad();
    }

    ValidateTime(input)
    {
        let retVal = true;

        if (utl.DateTimeValid(input.value) == false)
        {
            retVal = false;
            input.style.backgroundColor = "red";
        }

        return retVal;
    }

    ValidateTimeStart() { return this.ValidateTime(this.domDtGte); }
    ValidateTimeEnd() { return this.ValidateTime(this.domDtLte); }
    GetBand() { return this.domBand.value; }
    GetChannel() { return this.domChannel.value; }
    GetChannelPadded() { return ("000" + this.GetChannel()).slice(-3); }
    GetCallsign() { return this.domCallsign.value.trim(); }
    GetId13() { return WSPR.GetChannelDetails(this.GetBand(), this.GetChannel()).id13; }
    GetId1() { return this.GetId13().substring(0, 1); }
    GetId3() { return this.GetId13().substring(1); }
    GetMinRegular() { return WSPR.GetChannelDetails(this.GetBand(), this.GetChannel()).min; }
    GetMinEncoded() { return (this.GetMinRegular() + 2) % 10; }
    GetLane() { return WSPR.GetChannelDetails(this.GetBand(), this.GetChannel()).lane; }
    GetLimit() { return this.domLimit.value; }
    GetTimeStart() { return utl.MakeDateFrom(this.domDtGte.value); }
    GetTimeEndRaw() { return utl.MakeDateFrom(this.domDtLte.value); }
    GetTimeEnd()
    {
        // let the end time (date) be inclusive
        // so if you have 2023-04-28 as the end date, everything for the entire
        // day should be considered.
        // since the querying system wants a cutoff date (lte datetime), we
        // just shift the date of today forward by an entire day, changing it from
        // a cutoff of today at morning midnight to tomorrow at morning midnight

        let ms = utl.ParseTimeToMs(this.domDtLte.value);
        ms += (24 * 60 * 60 * 1000);

        // let retVal = utl.MakeDateTimeFromMs(ms);
        let retVal = utl.MakeDateFromMs(ms);

        return retVal;
    }
    SetStatus(status) { this.domStatus.innerHTML = status; }
    GetTargetTableCombined() { return this.domTargetTableCombined; }

    OnFormChange()
    {
        let url = new URL(window.location);

        url.searchParams.set("band", this.GetBand());
        url.searchParams.set("channel", this.GetChannel())
        url.searchParams.set("callsign", this.GetCallsign())
        url.searchParams.set("limit", this.GetLimit());
        url.searchParams.set("dtGte", this.domDtGte.value.trim());
        url.searchParams.set("dtLte", this.domDtLte.value.trim());

        if (this.ValidateTimeStart() && this.ValidateTimeEnd())
        {
            window.location = url.href;
        }
    }

    OnPageLoad()
    {
        const params = new URLSearchParams(window.location.search);

        utl.SetDomValBySearchParam(this.domBand, "band");
        utl.SetDomValBySearchParam(this.domChannel, "channel");
        utl.SetDomValBySearchParam(this.domCallsign, "callsign");
        utl.SetDomValBySearchParam(this.domLimit, "limit");
        utl.SetDomValBySearchParam(this.domDtGte, "dtGte");
        utl.SetDomValBySearchParam(this.domDtLte, "dtLte");

        if (this.domDtGte.value.trim() == "" || this.domDtLte.value.trim() == "")
        {
            let msNow = utl.Now();
            let msThen = msNow - (30 * 24 * 60 * 60 * 1000);

            this.domDtGte.value = utl.MakeDateFromMs(msThen);
            this.domDtLte.value = utl.MakeDateFromMs(msNow);

            this.OnFormChange();
        }
        else
        {
            if (this.QueryIsOkToDo())
            {
                // return;
                this.ss.Search(
                    this.GetBand(),
                    this.GetChannel(),
                    this.GetCallsign(),
                    this.GetTimeStart(),
                    this.GetTimeEnd(),
                    this.GetLimit()
                ).then(() => {
                    // load iframes (async)
                    this.LoadIframes();

                    // sync
                    this.PreprocessData();
                    
                    // show data
                    this.ShowData();
                });
            }
            else
            {
                autl.ToastErr("Please fill out the search criteria!");
            }
        }
    }

    LoadIframes()
    {
        let ms = Date.now();
        for (const ifInfo of this.ifInfoList)
        {
            document.getElementById(ifInfo.id).src = `./ChartTimeSeries.html?ms=${ms}`;
        }
    }

    PreprocessData()
    {
        // need to decide if page will:
        // - use only complete rows
        // - use partial rows
        //
        // - and for table display, does that differ?
        //
        // - do you visually indicate?

        // get the data and manage through convenience interface
        this.dataTable = this.ss.GetDataTable();
        this.td = new TabularData(this.dataTable);

        // drop the unneeded EncTime column
        // it's defined to be the 2min mark after the spot
        // just wastes space in a table already quite wide
        this.td.DeleteColumn("EncTime")

        // Preprocess Altitude
        this.td.AppendGeneratedColumns([
            "AltFt"
        ], row => {
            let retVal = [null];
            
            let altM = this.td.Get(row, "AltM");
            if (altM != null)
            {
                let altFt = Math.round(altM * 3.28084);
                
                retVal = [altFt];
            }

            return retVal;
        });

        // Preprocess Speed
        this.td.AppendGeneratedColumns([
            "SpeedKph", "SpeedMph"
        ], row => {
            let retVal = [null, null];

            let speedKnots = this.td.Get(row, "SpeedKnots");
            if (speedKnots != null)
            {
                let speedKph = Math.round(speedKnots * 1.852);
                let speedMph = Math.round(speedKnots * 1.15078);

                retVal = [speedKph, speedMph];
            }

            return retVal;
        });

        // Preprocess Temperature
        this.td.AppendGeneratedColumns([
            "TempF"
        ], row => {
            let retVal = [null];
            
            let tempC = this.td.Get(row, "TempC");
            if (tempC != null)
            {
                let tempF = Math.round((tempC * (9/5) + 32));

                retVal = [tempF];
            }

            return retVal;
        });

        // Preprocess Voltage


        // Final pass to jazz up the table presentation (data modified and not machine readable easily anymore)

        // sneakily take note of the latest grid6 for mapping purposes
        this.grid6Latest = null;

        // synthesize grid6
        this.td.AppendGeneratedColumns([
            "Grid6"
        ], row => {
            let grid4 = this.td.Get(row, "RegGrid");
            let grid56 = this.td.Get(row, "Grid56");

            let retVal = [""];

            if (grid56 != null)
            {
                let grid6 = grid4 + grid56;

                if (this.grid6Latest == null)
                {
                    this.grid6Latest = grid6;
                }

                let [lat, lng] = WSPREncoded.DecodeMaidenheadToDeg(grid6);

                let gmUrl = WSPREncoded.MakeGoogleMapsLink(lat, lng);
                let grid6Link = `<a href="${gmUrl}" target="_blank">${grid6}</a>`;

                retVal = [grid6Link];
            }

            return retVal;
        });


        // linkify grid4
        this.td.GenerateModifiedColumn([
            "RegGrid"
        ], row => {
            let grid4 = this.td.Get(row, "RegGrid");

            let [lat, lng] = WSPREncoded.DecodeMaidenheadToDeg(grid4);

            let gmUrl = WSPREncoded.MakeGoogleMapsLink(lat, lng);
            let grid4Link = `<a href="${gmUrl}" target="_blank">${grid4}</a>`;

            let retVal = [grid4Link];

            return retVal;
        });
    }

    ShowData()
    {
        // drop a map in there
        if (this.grid6Latest)
        {
            let [lat, lng] = WSPREncoded.DecodeMaidenheadToDeg(this.grid6Latest);

            // calculate bounding box
            let offset = 1.2;

            let latUL = lat + offset;
            let latLR = lat - offset;
            let lngUL = lng + offset;
            let lngLR = lng - offset;

            let url = new URL("https://www.openstreetmap.org/export/embed.html");

            url.searchParams.set("band", this.GetBand());
            url.searchParams.set("bbox", `${lngUL},${latUL},${lngLR},${latLR}`);
            url.searchParams.set("layer", `mapnik`);
            url.searchParams.set("marker", `${lat},${lng}`);

            document.getElementById("graphMap").src = url.href;
        }


        // show the same source data the graphs get

        // construct dom table
        let table = utl.MakeTable(this.dataTable);

        // make sortable
        sorttable.makeSortable(table);

        // insert
        let target = document.getElementById("targetTableCombined");

        target.innerHTML = "";
        target.appendChild(table);
    }

    OnGraphAltitude(to)
    {
        // chop out just the columns we care about for this graph
        let dataTable = this.td.Extract(["DateTimeLocal", "AltM", "AltFt"]);

        // send off to get graphed
        to.postMessage({
            type: "REP_DATA_TWO_UNITS",
            dataTable: dataTable,
        }, "*");
    }

    OnGraphSpeed(to)
    {
        // chop out just the columns we care about for this graph
        let dataTable = this.td.Extract(["DateTimeLocal", "SpeedKph", "SpeedMph"]);

        // send off to get graphed
        to.postMessage({
            type: "REP_DATA_TWO_UNITS",
            dataTable: dataTable,
        }, "*");
    }

    OnGraphTemperature(to)
    {
        // chop out just the columns we care about for this graph
        let dataTable = this.td.Extract(["DateTimeLocal", "TempC", "TempF"]);

        // send off to get graphed
        to.postMessage({
            type: "REP_DATA_TWO_UNITS",
            dataTable: dataTable,
        }, "*");
    }

    OnGraphVoltage(to)
    {
        // chop out just the columns we care about for this graph
        let dataTable = this.td.Extract(["DateTimeLocal", "Voltage"]);

        // send off to get graphed
        to.postMessage({
            type: "REP_DATA",
            dataTable: dataTable,
        }, "*");
    }


    QueryIsOkToDo()
    {
        let retVal =
            this.GetBand()      != "" && 
            this.GetChannel()   != "" &&
            this.GetCallsign()  != "" &&
            this.GetTimeStart() != "" &&
            this.GetTimeEnd()   != "" &&
            this.GetLimit()     != "";

        return retVal;
    }
}

export let app = null;

window.addEventListener('DOMContentLoaded', (event) => {
    app = new App();
    window.app = app;
});

</script>

<link rel="stylesheet" type="text/css" href="/css/traquito.css">

<style>

iframe {
    border: 1px solid black;
    width: 600px;
    height: 300px;
    resize: both;
}


.map {
    width: 1210px;
    height: 500px;
}






table {
    border: 1px solid black;
    border-collapse: collapse;
}

th, td {
    border: 1px solid lightgrey;
    border-collapse: collapse;
}

th {
    min-width: 30px;
    background-color: lightblue;
    border: 1px solid black;
}

th, td {
    text-align: center;
    padding: 2px;
}











</style>

    </head>
    <body>
        <div class="linkbar">
            <a href="/" target="_blank">Home</a> > <a href="/channelmap/" target="_blank">Channel Map</a> > Spot Search Dashboard
        </div>
        <label for='band'>Band </label>
        <select id="band" title="band">
            <option value="2190m">2190m (LF)</option>
            <option value="630m">630m (MF)</option>
            <option value="160m">160m</option>
            <option value="80m">80m</option>
            <option value="60m">60m</option>
            <option value="40m">40m</option>
            <option value="30m">30m</option>
            <option value="20m" selected>20m</option>
            <option value="17m">17m</option>
            <option value="15m">15m</option>
            <option value="12m">12m</option>
            <option value="10m">10m</option>
            <option value="6m">6m</option>
            <option value="4m">4m</option>
            <option value="2m">2m</option>
            <option value="70cm">70cm</option>
            <option value="23cm">23cm</option>
        </select>

        <label for='channel'>Channel </label><input id="channel" type="number" value="" min="0" max="599" title="channel" placeholder="channel">

        <label for='callsign'>Callsign </label><input id="callsign" title="callsign" placeholder="callsign" size="7"></input>

        <button id="go">search</button>

        <label for="limit">Max Rows </label><input id="limit" type="text" value="100" size="4" title="limit">

        <label for='dtGte'>Start </label><input id='dtGte' type='text' placeholder='YYYY-MM-DD' required pattern="\d{4}-\d{2}-\d{2}" spellcheck='false' size="10" maxlength="10">
        <label for='dtLte'>End </label><input id='dtLte' type='text' placeholder='YYYY-MM-DD' required pattern="\d{4}-\d{2}-\d{2}" spellcheck='false' size="10" maxlength="10">
        <br/>
        <span id="status"></span>
        <br/>

        <iframe class="map" id="graphMap">[Map if Grid6 available]</iframe>
        <div id="graphContainer">
            <iframe class="graph" id="graphAltitude"></iframe>
            <iframe class="graph" id="graphSpeed"></iframe>
            <br/>
            <iframe class="graph" id="graphTemperature"></iframe>
            <iframe class="graph" id="graphVoltage"></iframe>
        </div>

        <br/>
        <br/>
        <br/>
        
        <a href="#" id="downloadCombined">(download)</a> or
        <a href="#" id="copyCombined">(copy to clipboard)</a>
        <div id="targetTableCombined"></div>
        
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>

    </body>
</html>
