<html>
    <head>
        <title>Channel Search</title>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-07H1M3KB40"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-07H1M3KB40');
</script>

        <script type='module'>
import * as utl from './js/Utl.js';
import { WsprLiveQuerier } from './js/WsprLiveQuerier.js';
import { QrpLabsQuerier } from './js/QrpLabsQuerier.js';


export class App
{
    constructor()
    {
        this.tdAttrSet = new Set();

        this.wspr = new WsprLiveQuerier();
        this.qrp  = new QrpLabsQuerier();

        this.domBand = document.getElementById("band");
        this.domDtGte = document.getElementById("dtGte");
        this.domDtLte = document.getElementById("dtLte");
        this.domGo = document.getElementById("go");
        this.domQueryLink = document.getElementById("queryLink");

        // bootstrap the load/reload logic
        this.OnPageLoad();

        this.domBand.onchange = e => {
            console.log(`onchange ${this.domBand.value}`);
            this.OnFormChange();
        };

        this.domGo.onclick = e => {
            console.log(`onclick`);
            this.OnFormChange();
        };
    }

    GetBand()
    {
        return parseInt(this.domBand.value);
    }

    SetQueryLink(query)
    {
        let urlMaker = new URL(`/QueryWsprLive.html`, window.location);
        urlMaker.searchParams.set("query", query);

        this.domQueryLink.href = urlMaker.href;
    }

    OnFormChange()
    {
        // load up the url
        let url = new URL(window.location);

        url.searchParams.set("band", this.GetBand());
        // url.searchParams.set("dtGte", this.domDtGte.value);
        // url.searchParams.set("dtLte", this.domDtLte.value);

        window.location = url.href;
    }

    OnPageLoad()
    {
        const params = new URLSearchParams(window.location.search);

        if (params.has("band"))
        {
            let band = params.get("band").trim();

            if (band != "")
            {
                this.domBand.value = band;
            }
        }
        else
        {
            console.log("no band param");
        }

        this.PopulateTable();
    }

    MakeTableFor(band, id1List)
    {
        let id3List = [`0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`];

        // the table
        let table = document.createElement(`table`);
        table.classList.add("mainTable");

        // create table header
        let colNameList = [];
        for (const id1 of id1List)
        {
            for (const id3 of id3List)
            {
                let colName = id1 + id3;

                colNameList.push(colName);
            }
        }

        colNameList.push(`min`)
        colNameList.push(`freqBand`);
        colNameList.push(`freq`);
        let trHeader = document.createElement(`tr`);
        for (const colName of colNameList)
        {
            let th = document.createElement(`th`);
            th.innerHTML = colName;

            trHeader.appendChild(th);
        }
        table.appendChild(trHeader);

        // create every row
        let minuteList = [8, 0, 2, 4, 6];

        let band__dialFreq = new Map();
        band__dialFreq.set(160,  1836600);
        band__dialFreq.set(80,   3592600);
        band__dialFreq.set(60,   5287200);
        band__dialFreq.set(40,   7038600);
        // band__dialFreq.set(32,  10138700);
        band__dialFreq.set(20,  14095600);
        band__dialFreq.set(17,  18104600);
        band__dialFreq.set(15,  21094600);
        band__dialFreq.set(12,  24924600);
        band__dialFreq.set(10,  28124600);
        band__dialFreq.set(6,   50293000);
        band__dialFreq.set(2,  144488500);

        if (band__dialFreq.has(band) == false)
        {
            band = 20;
        }

        let dialFreq = band__dialFreq.get(band);

        let freqTxLow = dialFreq + 1500 - 100;
        let freqTxHigh = dialFreq + 1500 + 100;
        let freqTxWindow = freqTxHigh - freqTxLow;

        let freqBandCount = 5;
        let bandSizeHz = freqTxWindow / freqBandCount;

        let freqBandList = [1, 2, 4, 5];    // skip middle band 3, but really label as 1,2,3,4

        let rowCount = 0;
        for (const freqBand of freqBandList)
        {
            // figure out the frequency
            let freqBandLow    = (freqBand - 1) * bandSizeHz;
            let freqBandHigh   = freqBandLow + bandSizeHz;
            let freqBandCenter = (freqBandHigh + freqBandLow) / 2;

            let rowsPerCol = freqBandCount * freqBandList.length;

            for (const minute of minuteList)
            {
                let freqBandLabel = freqBand;
                if (freqBandLabel >= 4) { freqBandLabel = freqBandLabel - 1; }
                
                let tr = document.createElement(`tr`);
                
                for (const id1 of id1List)
                {
                    let colCount = 0;
                    let id1Offset = 0;
                    if (id1 == `1`) { id1Offset = 200; }
                    if (id1 == 'Q') { id1Offset = 400; }

                    for (const id3 of id3List)
                    {
                        let channel = id1Offset + (colCount * rowsPerCol) + rowCount;
                        
                        let td = document.createElement(`td`);
                        td.innerHTML = channel;

                        td.id = `channel-${channel}`;

                        let markerList = [
                            `id1-${id1}`,
                            `id3-${id3}`,
                            `channel-${channel}`,
                            `freqBand-${freqBand}`,
                            `freqBandLabel-${freqBandLabel}`,
                            `minute-${minute}`,
                        ];

                        for (const marker of markerList)
                        {
                            td.classList.add(marker);
                        }

                        let id3ListFirst = id3List[0];
                        let id3ListLast  = id3List[id3List.length - 1];

                        if (id3 == id3ListFirst)
                        {
                            td.classList.add(`id1ColFirst`);
                        }

                        if (id3 == id3ListLast)
                        {
                            td.classList.add(`id1ColLast`);
                        }

                        tr.appendChild(td);
    
                        ++colCount;
                    }
                }

                let tdMin = document.createElement(`td`);
                tdMin.innerHTML = minute;

                let tdFreq = document.createElement(`td`);
                tdFreq.innerHTML = utl.Commas(freqTxLow + freqBandCenter);

                let tdFreqBand = document.createElement(`td`);

                tdFreqBand.innerHTML = freqBandLabel;

                for (const td of [tdMin, tdFreqBand, tdFreq])
                {
                    td.classList.add(`freqBand-${freqBand}`);
                    td.classList.add(`freqBandLabel-${freqBandLabel}`);
                    tr.appendChild(td);
                }

                let minuteFirst = minuteList[0];
                let minuteLast  = minuteList[minuteList.length - 1];

                if (minute == minuteFirst)
                {
                    tr.classList.add("freqBandRowFirst");
                }

                if (minute == minuteLast)
                {
                    tr.classList.add("freqBandRowLast");
                }
                
                table.appendChild(tr);

                ++rowCount;
            }
        }

        return table;
    }

    TdHasBalloonTelemetry(td)
    {
        let attrs = this.GetTdAttributes(td);

        return attrs.count != undefined;
    }

    GiveTdAttributes(td, attrObj)
    {
        for (const [key, value] of Object.entries(attrObj))
        {
            td.setAttribute(`data-${key}`, value);

            this.tdAttrSet.add(key);
        }
    }

    GetTdAttributes(td)
    {
        let retVal = {};

        for (const attrName of this.tdAttrSet)
        {
            retVal[attrName] = td.getAttribute(`data-${attrName}`);
        }

        return retVal;
    }

    infoFrozen = false;
    OnClickTable()
    {
        this.infoFrozen = !this.infoFrozen;
    }

    OnTdChannelHover(td)
    {
        let attrs = this.GetTdAttributes(td);

        // decide how to transcribe attributes without enrichment
        let attrDescMap = {
            count: "Ballon telem count",
        };

        let descValMap = {};
        
        for (const [attr, desc] of Object.entries(attrDescMap))
        {
            descValMap[desc] = attrs[attr];
        }

        // add any enriched attributes
        if (attrs.url)
        {
            descValMap["QRP Callsign"] = attrs.callsign;
            descValMap["Tracking site"] = `<a href='${attrs.url}'>${attrs.flightName}</a>`;
        }

        // construct and use table
        let table = document.createElement("table");
        for (const [desc, val] of Object.entries(descValMap))
        {
            let tr = document.createElement("tr");

            let tdDesc = document.createElement("th");
            let tdVal = document.createElement("td");

            tdDesc.innerHTML = desc;
            tdVal.innerHTML = val;

            tr.appendChild(tdDesc);
            tr.appendChild(tdVal);

            if (val != undefined)
            {
                table.appendChild(tr);
            }
        }

        if (!this.infoFrozen)
        {
            let info = document.getElementById("info");
            info.innerHTML = "";
            info.appendChild(table);
        }
    }

    MakeTable()
    {
        let id1List = [`0`, `1`, `Q`];

        let band = this.GetBand();
        let table = this.MakeTableFor(band, id1List);

        for (let td of table.getElementsByTagName("td"))
        {
            if (td.id.includes("channel-"))
            {
                td.onmouseover = e => {
                    this.OnTdChannelHover(td);
                };
            }
        }

        table.onclick = e => {
            this.OnClickTable();
        }

        document.getElementById(`channelTarget`).appendChild(table);

        this.tdList = table.getElementsByTagName(`td`);
    }

    GetTdByKey(id1, id3, freqBand, minute)
    {
        let retVal = null;

        for (const td of this.tdList)
        {
            let str = td.classList.value;

            if (str.includes(`id1-${id1}`) &&
                str.includes(`id3-${id3}`) &&
                str.includes(`freqBand-${freqBand}`) &&
                str.includes(`minute-${minute}`))
            {
                retVal = td;
                break;
            }
        }

        return retVal;
    }

    GetTdByChannel(channel)
    {
        return document.getElementById(`channel-${channel}`);
    }

    async QueryWsprLive()
    {
        let band = this.GetBand();

        let query = this.wspr.GetPossibleBalloonTelemetryU4BQuery(band);
        this.SetQueryLink(query);

        let dataTable = await this.wspr.GetPossibleBalloonTelemetryU4B(band);

        console.log("got wspr data");

        // first pass - find highest value
        let max = 0;
        for (const rowData of dataTable)
        {
            let [freqAvg, id1, id3, freqBand, minute, count] = rowData;

            count = parseInt(count);

            if (count > max)
            {
                max = count;
            }
        }

        for (const rowData of dataTable)
        {
            let [freqAvg, id1, id3, freqBand, minute, count] = rowData;
            count = parseInt(count);

            // filter out bad data
            let useData = true;
            if (!([1, 2, 4, 5].includes(freqBand))) { useData = false; }
            if ((minute % 2) != 0) { useData = false; }

            if (useData)
            {
                let td = this.GetTdByKey(id1, id3, freqBand, minute);
                
                if (td)
                {
                    let pct = count / max * 100;
                    let pctClamp = pct;

                    // boost the color because hard to see
                    let pctMin = 15;
                    if (pct < pctMin)
                    {
                        pctClamp = pctMin;
                    }
                    else
                    {
                        pctClamp += pctMin;

                        if (pctClamp > 100)
                        {
                            pctClamp = 100;
                        }
                    }

                    // make the color math work
                    let pctColor = 100 - pctClamp;

                    let rgbColor = utl.ColorPctBetween(pctColor, "white", "yellow");
                    td.style.backgroundColor = rgbColor;

                    this.GiveTdAttributes(td, {
                        count : utl.Commas(count),
                        pct: Math.round(pct),
                    });
                }
                else
                {
                    console.log(`looking for ${id1} ${id3} ${freqBand} ${minute}`);
                    console.log("ERR COULDN'T FIND");
                    console.log(rowData);
                }
            }
        }
    }

    async QueryQrpLabs()
    {
        let rowList = await this.qrp.GetChannelData();

        console.log("got qrp data");

        for (const row of rowList)
        {
            let [flightName, url, callsign, channel, lastHeard, altitude] = row;

            let td = this.GetTdByChannel(channel);

            if (td)
            {
                let pct = 25;
                let pctUse = 100 - pct;
                let rgbColor = utl.ColorPctBetween(pctUse, "white", "red");

                this.GiveTdAttributes(td, {
                    flightName : flightName,
                    url: url,
                    callsign: callsign,
                });

                if (this.TdHasBalloonTelemetry(td) == false)
                {
                    td.style.background = rgbColor;
                }
                else
                {
                    td.style.background = "linear-gradient(90deg, rgba(255,255,0,1) 0%, rgba(255,191,191,1) 100%)";
                }
            }
            else
            {
                console.log(`Could not find td for channel ${channel}`);
            }
        }
    }

    async PopulateTable()
    {
        this.MakeTable();

        const params = new URLSearchParams(window.location.search);

        if (params.get("queryWsprLive") != 0)
        {
            await this.QueryWsprLive();
        }
        
        if (params.get("queryQrpLabs") != 0)
        {
            await this.QueryQrpLabs();
        }
    }
}

export let app = null;

window.addEventListener('DOMContentLoaded', (event) => {
    app = new App();
    window.app = app;
});

</script>
<style>
* {
    font-family: Consolas,monaco,monospace;
    font-size: small;
}

table {
    border: 1px solid black;
    border-collapse: collapse;
}

th, td {
    border: 1px solid lightgrey;
    border-collapse: collapse;
}

th {
    min-width: 30px;
    background-color: lightblue;
    border: 1px solid black;
}

td {
    text-align: center;
}

.possibleBalloonTelemetry {
    background-color: yellow;
}

.id1ColFirst {
}

.id1ColLast {
    border-right: 2px solid black;
}

.freqBandRowFirst {
    border-top: 2px solid black;
}

.freqBandRowLast {
    border-bottom: 2px solid black;
}

/*
https://codepen.io/kevintcoughlin/pen/xVqyGV
*/

table {
    overflow: hidden;
    z-index: 1;
}

td, th, .row, .col {
    /* cursor: pointer; */
    position: relative;
}

td:hover::before,
.row:hover::before { 
    background-color: lightblue;
    content: '\00a0';  
    height: 100%;
    /* left: -5000px; */
    position: absolute;  
    top: 0;
    width: 10000px;   
    z-index: -1;        
}

td:hover::after,
.col:hover::after { 
    background-color: lightblue;
    content: '\00a0';  
    height: 10000px;    
    left: 0;
    position: absolute;  
    top: -5000px;
    width: 100%;
    z-index: -1;        
}


</style>

    </head>
    <body>
        <select id="band">
            <option value=160>160m</option>
            <option value=80>80m</option>
            <option value=60>60m</option>
            <option value=40>40m</option>
            <!-- <option value=32>32m</option> -->
            <option value=20 selected>20m</option>
            <option value=17>17m</option>
            <option value=15>15m</option>
            <option value=12>12m</option>
            <option value=10>10m</option>
            <option value=6>6m</option>
            <option value=2>2m</option>
        </select>
        timeStart <input id='dtGte' type='text' placeholder='YYYY-MM-DD HH:MM:SS' spellcheck='false'>
        timeEnd <input id='dtLte' type='text' placeholder='YYYY-MM-DD HH:MM:SS' spellcheck='false'>
        <button id="go">go</button>
        <a id="queryLink" href="">(link to data)</a>
        <br/>
        <div id="channelTarget"></div>
        <br/>
        Click to freeze/unfreeze info
        <br/>
        <div id="info"></div>
    </body>
</html>